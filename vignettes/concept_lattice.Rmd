---
title: "Using FormalContexts and ConceptLattices"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using FormalContexts and ConceptLattices}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

In this vignette, we present the main functionalities and data structures of the `fcaR` package when working with formal contexts and concepts, in FCA.

We load the `fcaR` package by:
```{r setup}
library(fcaR)
```

# Datasets

We are going to work with two datasets, a crisp one and a fuzzy one.

The classical (binary) dataset is the well-known `planets` formal context, presented in 

> Wille R (1982). “Restructuring Lattice Theory: An Approach Based on Hierarchies of Concepts.” In Ordered Sets, pp. 445–470. Springer.

```{r echo = FALSE}
objects <- c("Mercury", "Venus", "Earth", "Mars",
             "Jupiter", "Saturn", "Uranus", "Neptune",
             "Pluto")

attributes <- c("small", "medium", "large",
                "near", "far",
                "moon", "no_moon")

planets <- matrix(0, nrow = length(objects),
                  ncol = length(attributes))

rownames(planets) <- objects
colnames(planets) <- attributes

planets["Mercury", c("small", "near", "no_moon")] <- 1
planets["Venus", c("small", "near", "no_moon")] <- 1
planets["Earth", c("small", "near", "moon")] <- 1
planets["Mars", c("small", "near", "moon")] <- 1
planets["Jupiter", c("large", "far", "moon")] <- 1
planets["Saturn", c("large", "far", "moon")] <- 1
planets["Uranus", c("medium", "far", "moon")] <- 1
planets["Neptune", c("medium", "far", "moon")] <- 1
planets["Pluto", c("small", "far", "moon")] <- 1
```

```{r}
knitr::kable(planets, format = "html", booktabs = TRUE)
```

The other formal context is fuzzy and is defined by the following matrix I:
```{r echo = FALSE}
objects <- paste0("O", 1:6)
n_objects <- length(objects)

attributes <- paste0("P", 1:6)
n_attributes <- length(attributes)

I <- matrix(data = c(0, 1, 0.5, 0, 0, 0.5,
                     0, 1, 0.5, 0, 0, 0.5,
                     0.5, 1, 0, 0, 1, 0,
                     0.5, 0, 0, 1, 0.5, 0,
                     1, 0, 0, 0.5, 0, 0,
                     0, 0, 1, 0, 0, 1),
            nrow = n_objects,
            byrow = FALSE)

colnames(I) <- attributes
rownames(I) <- objects
```

```{r}
knitr::kable(I, format = "html", booktabs = TRUE)
```

# Working with Formal Contexts

The first step when using the `fcaR` package to analyse a formal context is to create an object of class `FormalContext` which will store all the information related to the context.

In our examples, we create two objects:
```{r}
fc_planets <- FormalContext$new(planets)
fc_I <- FormalContext$new(I)
```

Internally, the object stores information about whether the context is binary or the names of objects and attributes, which are taken from the rownames and colnames of the provided matrix.

## Plotting, printing and latex-ing the FormalContext

Once created the `FormalContext` objects, we can print them or plot them as heatmaps (with functions `print()` and `plot()`):
```{r}
print(fc_planets)
print(fc_I)
```

```{r}
fc_planets$plot()
fc_I$plot()
```

Also, we can export the formal context as a LaTeX table:
```{r echo=TRUE, results="markup", comment = ""}
fc_planets$to_latex()
```

## Closures

The basic operation in FCA is the computation of closures given an attribute set, by using the two derivation operators, extent and intent.

The intent of a (probably fuzzy) set of objects is the set of their common attributes:
```{r}
# Define a set of objects
S <- SparseSet$new(attributes = fc_planets$objects)
S$assign(attributes = c("Earth", "Mars"), values = c(1, 1))
S

# Compute the intent of S
fc_planets$get_intent(S)
```

Analogously, the extent of a set of attributes is the set of objects which possess all the attributes in the given set:
```{r}
# Define a set of objects
S <- SparseSet$new(attributes = fc_planets$attributes)
S$assign(attributes = c("moon", "large"), values = c(1, 1))
S

# Compute the extent of S
fc_planets$get_extent(S)
```

the composition of intent and extent is the closure of a set of attributes:
```{r}
# Compute the closure of S
Sc <- fc_planets$get_closure(S)
Sc
```

This means that all planets which have the attributes `moon` and `large` also have `far` in common.

We can check whether a set is closed (that is, it is equal to its closure), using `is_closed()`:
```{r}
fc_planets$is_closed(S)
fc_planets$is_closed(Sc)
```



## Clarification and Reduction

An interesting point when managing formal contexts is the ability to reduce the context, removing redundancies, while retaining all the knowledge. This is accomplished by two functions: `clarify()`, which removes duplicated attributes and objects (columns and rows in the original matrix); and `reduce()`, which uses closures to remove dependent attributes, but only on binary formal contexts. The resulting `FormalContext` is equivalent to the original one in both cases.

```{r}
fc_planets$reduce(TRUE)

fc_I$clarify(TRUE)
```

Note that merged attributes or objects are stored in the new formal context by using squared brackets to unify them, e.g. `[Mercury, Venus]`.

## Extracting Implications and Concepts

The function to extract the canonical basis of implications and the concept lattice is `extract_implications_concepts()`. Its use is to store a `ConceptLattice` and an `ImplicationSet` objects internally in the `FormalContext` object after running the NextClosure algorithm.

It can be used both for binary and fuzzy formal contexts, resulting in binary or fuzzy concepts and implications:
```{r}
fc_planets$extract_implications_concepts()

fc_I$extract_implications_concepts()
```

We can inspect the results as:
```{r}
# Concepts
fc_planets$concepts

# Implications
fc_planets$implications
```



## Standard Context


## Saving and loading

# Concept Lattice

Use the previously extracted

## Plot, print and LaTeX

## Getting all extents, intents and subsetting concepts

## Sublattices

## Infima and suprema, subconcepts and superconcepts

## Join- and meet- irreducible elements

## Concept support
