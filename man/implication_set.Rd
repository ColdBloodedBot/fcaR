% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/implication_set.R
\name{implication_set}
\alias{implication_set}
\title{R6 Class for Set of implications}
\description{
This class implements the structure needed to store implications and the methods associated.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{implication_set$new()}}
\item \href{#method-get_attributes}{\code{implication_set$get_attributes()}}
\item \href{#method-to_arules}{\code{implication_set$to_arules()}}
\item \href{#method-add_implication}{\code{implication_set$add_implication()}}
\item \href{#method-append_implications}{\code{implication_set$append_implications()}}
\item \href{#method-cardinality}{\code{implication_set$cardinality()}}
\item \href{#method-is_empty}{\code{implication_set$is_empty()}}
\item \href{#method-size}{\code{implication_set$size()}}
\item \href{#method-compute_closure}{\code{implication_set$compute_closure()}}
\item \href{#method-recommend}{\code{implication_set$recommend()}}
\item \href{#method-apply_rules}{\code{implication_set$apply_rules()}}
\item \href{#method-print}{\code{implication_set$print()}}
\item \href{#method-to_latex}{\code{implication_set$to_latex()}}
\item \href{#method-get_LHS_matrix}{\code{implication_set$get_LHS_matrix()}}
\item \href{#method-get_RHS_matrix}{\code{implication_set$get_RHS_matrix()}}
\item \href{#method-filter}{\code{implication_set$filter()}}
\item \href{#method-get_rules}{\code{implication_set$get_rules()}}
\item \href{#method-remove_rules}{\code{implication_set$remove_rules()}}
\item \href{#method-clone}{\code{implication_set$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Initialize with an optional name
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$new(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{See Details.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Creates and initialize a new \code{FormalContext} object. It can be done in two ways:
\code{initialize(name, attributes, lhs, rhs)}
or \code{initialize(rules)}

In the first way, the only mandatory argument is \code{attributes}, (character vector) which is a vector of names of the attributes on which we define the implications. Optional arguments are: \code{name} (character string), name of the implication set, \code{lhs} (a \code{dgCMatrix}), initial LHS of the implications storedand the analogous \code{rhs}.

The other way is used to initialize the \code{FormalContext} object from a \code{rules} object from package \code{arules}.
}

\subsection{Returns}{
A new \code{implication_set} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_attributes"></a>}}
\subsection{Method \code{get_attributes()}}{
Get the names of the attributes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$get_attributes()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A character vector with the names of the attributes used in the implications.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_arules"></a>}}
\subsection{Method \code{to_arules()}}{
Convert to arules format
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$to_arules()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A \code{rules} object as used by package \code{arules}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add_implication"></a>}}
\subsection{Method \code{add_implication()}}{
Add new implication to the set
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$add_implication(lhs, rhs)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lhs}}{(a sparse matrix) The LHS of the rule to add.}

\item{\code{rhs}}{(a sparse matrix) The RHS of the rule to add.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nothing, just updates the internal matrices for LHS and RHS.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-append_implications"></a>}}
\subsection{Method \code{append_implications()}}{
Append implications to the current ones.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$append_implications(implications)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{implications}}{(\code{ImplicationSet}) The set of implications to append at the end of the current set.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nothing, just updates the internal matrices for LHS and RHS.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cardinality"></a>}}
\subsection{Method \code{cardinality()}}{
Cardinality: Number of implications in the set
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$cardinality()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The cardinality of the implication set.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_empty"></a>}}
\subsection{Method \code{is_empty()}}{
Empty set
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$is_empty()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{TRUE} if the set of implications is empty, \code{FALSE} otherwise.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-size"></a>}}
\subsection{Method \code{size()}}{
Size: number of attributes in each of LHS and RHS
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$size()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A vector with two components: the number of attributes present in each of the LHS and RHS of each implication in the set.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-compute_closure"></a>}}
\subsection{Method \code{compute_closure()}}{
Compute the semantic closure of a fuzzy set with respect to the implication set
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$compute_closure(S, reduce = FALSE, verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{S}}{(a \code{SparseSet} object)  Fuzzy set to compute its closure. Use class \code{SparseSet} to build it.}

\item{\code{reduce}}{(logical) Reduce the implications using simplification logic?}

\item{\code{verbose}}{(logical) Show verbose output?}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
If \code{reduce == FALSE}, the output is a fuzzy set corresponding to the closure of \code{S}. If \code{reduce == TRUE}, a list with two components: \code{closure}, with the closure as above, and \code{implications}, the reduced set of implications.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-recommend"></a>}}
\subsection{Method \code{recommend()}}{
Generate a recommendation for a subset of the attributes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$recommend(S, attribute_filter)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{S}}{(a vector) Vector with the grades of each attribute (a fuzzy set).}

\item{\code{attribute_filter}}{(character vector) Names of the attributes to get recommendation for.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A fuzzy set describing the values of the attributes in \code{attribute_filter} within the closure of \code{S}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_rules"></a>}}
\subsection{Method \code{apply_rules()}}{
Apply rules to remove redundancies
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$apply_rules(
  rules = c("composition", "generalization"),
  batch_size = 25000L,
  parallelize = TRUE,
  reorder = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rules}}{(character vector) Names of the rules to use. See \code{details}.}

\item{\code{batch_size}}{(integer) If the number of rules is large, apply the rules by batches of this size.}

\item{\code{parallelize}}{(logical) If possible, should we parallelize the computation among different batches?}

\item{\code{reorder}}{(logical) Should the rules be randomly reordered previous to the computation?}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Currently, the implemented rules are \code{"generalization"}, \code{"simplification"}, \code{"reduction"} and \code{"composition"}.
}

\subsection{Returns}{
Nothing, just updates the internal matrices for LHS and RHS.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\subsection{Method \code{print()}}{
Print all implications to text
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$print()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A string with all the implications in the set.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_latex"></a>}}
\subsection{Method \code{to_latex()}}{
Export to LaTeX
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$to_latex(
  ncols = 1,
  numbered = TRUE,
  numbers = seq(self$cardinality())
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ncols}}{(integer) Number of columns for the output.}

\item{\code{numbered}}{(logical) If \code{TRUE} (default), implications will be numbered in the output.}

\item{\code{numbers}}{(vector) If \code{numbered}, use these elements to enumerate the implications. The default is to enumerate 1, 2, ..., but can be changed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A string in LaTeX format that prints nicely all the implications.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_LHS_matrix"></a>}}
\subsection{Method \code{get_LHS_matrix()}}{
Get internal LHS matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$get_LHS_matrix()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A sparse matrix representing the LHS of the implications in the set.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_RHS_matrix"></a>}}
\subsection{Method \code{get_RHS_matrix()}}{
Get internal RHS matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$get_RHS_matrix()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A sparse matrix representing the RHS of the implications in the set.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-filter"></a>}}
\subsection{Method \code{filter()}}{
Filter implications by attributes in LHS and RHS
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$filter(lhs = NULL, rhs = NULL, drop = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lhs}}{(character vector) Names of the attributes to filter the LHS by. If \code{NULL}, no filtering is done on the LHS.}

\item{\code{rhs}}{(character vector) Names of the attributes to filter the RHS by. If \code{NULL}, no filtering is done on the RHS.}

\item{\code{drop}}{(logical) Remove the rest of attributes in RHS?}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \code{ImplicationSet} that is a subset of the current set, only with those rules which has the attributes in \code{lhs} and \code{rhs} in their LHS and RHS, respectively.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_rules"></a>}}
\subsection{Method \code{get_rules()}}{
Get a subset of the implication set
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$get_rules(idx)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{idx}}{(integer vector) Indices of the implications to extract.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{ImplicationSet} with only the rules given by the \code{idx} indices.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-remove_rules"></a>}}
\subsection{Method \code{remove_rules()}}{
Remove implications from the set
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$remove_rules(idx)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{idx}}{(integer vector) Indices of implications to remove.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \code{ImplicationSet} with the implications at given indices removed with respect to the original set.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{implication_set$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
